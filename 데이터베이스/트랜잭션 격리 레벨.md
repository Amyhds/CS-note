1. **Uncommitted Read (커밋되지 않은 읽기):** 다른 트랜잭션에서 커밋되지 않은 데이터에 접근할 수 있게 하는 격리 수준이다. 가장 저수준의 격리수준이며, 일반적으로 사용하지 않는 격리수준이다. 해당 격리 레벨에서 A트랜잭션이 데이터를 UPDATE하고 Commit하지 않았는데 이를 B트랜잭션이 읽었을 때, A트랜잭션이 롤백된다면 데이터 부정합이 발생할 수 있다. 커밋되지 않는 트랜잭션에 접근하여 부정합을 유발할 수 있는 데이터를 읽는 것을 더티읽기(Dirty Read)라고 한다.
    
2. **Committed Read (커밋된 읽기):** 다른 트랜잭션에서 커밋된 데이터로만 접근할 수 있게 하는 격리 수준이다. MySQL을 제외하고 대부분 이를 기본 격리수준으로 사용한다. A트랜잭션이 데이터를 UPDATE하고 Commit하지 않았을 때, B트랜잭션이 데이터를 읽으면 UPDATE 전 데이터 값이 조회된다. 따라서 Dirty Read는 발생하지 않는다. 하지만 Commit 전과 후의 데이터가 달라질 수 있기 때문에 Non Repeatable Read(반복 가능하지 않은 읽기) 현상이 발생한다.
    
    ⇒ Commit 하기 전 데이터를 읽어올 수 있는 이유는 변경 전 데이터가 저장된 Undo 영역에 있는 데이터를 읽어오기 때문이다.
    
3. **Repeatable Read (반복 가능한 읽기):** Non Repeatable Read 문제를 해결하는 격리 수준으로, 커밋된 데이터만 읽을 수 있되 자신보다 낮은 트랜잭션 번호를 갖는 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리수준이다. 이게 가능한 이유는 Undo 로그때문이다.
    
4. **Serializable:** 가장 고수준의 격리수준으로 트랜잭션을 무조건 ****순차적으로 진행시킨다. 트랜잭션이 끼어들 수 없으니 데이터의 부정합 문제는 발생하지 않으나, 동시 처리가 불가능하여 처리 속도가 느려진다. 트랜잭션이 중간에 끼어들 수 없는 이유는 SELECT 쿼리 실행 시 Shared Lock(공유 잠금)을, ****INSERT, UPDATE, DELETE 쿼리 실행 시 Exclusive Lock (MySQL의 경우 Nexy Key Lock)을 걸어버리기 때문이다.